---
date_content: 2016-05-12 08:40:37.000000
---
<p>Étude des mécanismes de transformation de modèles <span style="font-size: 12.16px; line-height: 1.3em;">CSP / SAT</span></p>\r\n<p> </p>\r\n<p>Encadrants</p>\r\n<p>BARICHARD, Vincent -- <span style="font-size: 12.16px; line-height: 1.3em;">Laboratoire : LERIA (UPRES EA 2645)</span></p>\r\n<p><span style="font-size: 12.16px; line-height: 1.3em;">Affiliation : Université d’Angers</span></p>\r\n<p><span style="font-size: 12.16px; line-height: 1.3em;">E-mail : vincent.barichard@univ-angers.fr</span></p>\r\n<p> </p>\r\n<p>LARDEUX, Frédéric -- <span style="font-size: 12.16px; line-height: 1.3em;">Laboratoire : LERIA (UPRES EA 2645)</span></p>\r\n<p><span style="font-size: 12.16px; line-height: 1.3em;">Affiliation : Université d’Angers</span></p>\r\n<p><span style="font-size: 12.16px; line-height: 1.3em;">E-mail : frederic.lardeux@univ-angers.fr</span></p>\r\n<p> </p>\r\n<p> </p>\r\n<p>Un CSP (Constraint Satisfaction Problem) est un formalisme permettant de modé<span style="font-size: 12.16px; line-height: 1.3em;">liser la plupart des problèmes avec contraintes. Un CSP est défini par un ensemble de </span><span style="font-size: 12.16px; line-height: 1.3em;">variables ainsi qu’un ensemble de contraintes liant les variables entre elles. Résoudre un </span><span style="font-size: 12.16px; line-height: 1.3em;">CSP consiste à trouver une affectation des variables qui satisfasse toutes les contraintes du </span><span style="font-size: 12.16px; line-height: 1.3em;">problème. L’une des principales forces des CSP est son langage déclaratif de haut niveau. </span></p>\r\n<p><span style="font-size: 12.16px; line-height: 1.3em;"> </span><span style="font-size: 12.16px; line-height: 1.3em;">L’utilisateur modélise son problème dans ce langage, mais n’implémente pas l’algorithme </span><span style="font-size: 12.16px; line-height: 1.3em;">pour le résoudre (la résolution est laissée à la charge d’un solveur). Le formalisme CSP est </span><span style="font-size: 12.16px; line-height: 1.3em;">riche, il comprend différents types de domaines pour les variables : domaines énumérés, </span><span style="font-size: 12.16px; line-height: 1.3em;">intervalles d’entiers ou de flottants, ensembles. Il intègre également une large bibliothèque </span><span style="font-size: 12.16px; line-height: 1.3em;">de contraintes prédéfinies : contraintes booléennes et arithmétiques, contraintes non li</span><span style="font-size: 12.16px; line-height: 1.3em;">néaires, contraintes ensemblistes, contraintes globales . . . La communauté a porté une </span><span style="font-size: 12.16px; line-height: 1.3em;">attention particulière à la définition et l’implémentation de contraintes globales comme </span><span style="font-size: 12.16px; line-height: 1.3em;">alldifferent (qui force toutes les variables d’une liste à avoir des valeurs différentes) ou </span><span style="font-size: 12.16px; line-height: 1.3em;">cumulative (qui est utilisé dans l’ordonnancement de tâches partageant des ressources). </span><span style="font-size: 12.16px; line-height: 1.3em;">Ces contraintes globales améliorent la résolution mais augmentent aussi la puissance du </span><span style="font-size: 12.16px; line-height: 1.3em;">langage.</span></p>\r\n<p><span style="font-size: 12.16px; line-height: 1.3em;">D’un autre côté, le problème de satisfiabilité en logique propositionnelle (SAT) est </span><span style="font-size: 12.16px; line-height: 1.3em;">moins riche car il ne comprend que des variables booléennes et des formules proposi</span><span style="font-size: 12.16px; line-height: 1.3em;">tionnelles. Cependant, les solveurs SAT sont maintenant très puissants et capables de </span><span style="font-size: 12.16px; line-height: 1.3em;">manipuler des instances de très grande taille (de plusieurs millions de variables). Depuis </span><span style="font-size: 12.16px; line-height: 1.3em;">plusieurs années, beaucoup d’efforts ont été fournis pour améliorer les solveurs SAT si </span><span style="font-size: 12.16px; line-height: 1.3em;">bien qu’aujourd’hui ils intègrent des techniques de résolution plus évoluées que les sol</span><span style="font-size: 12.16px; line-height: 1.3em;">veurs CSP. Pour pouvoir mettre à profit cette puissance, mais à partir d’un formalisme </span><span style="font-size: 12.16px; line-height: 1.3em;">plus riche comme CSP, il est naturel de vouloir convertir un problème CSP en problème </span><span style="font-size: 12.16px; line-height: 1.3em;">SAT.</span></p>\r\n<p> </p>\r\n<p>Transformer manuellement un problème CSP en SAT est une tâche fastidieuse source <span style="font-size: 12.16px; line-height: 1.3em;">d’erreurs. Transformer automatiquement de manière naïve un problème CSP en SAT </span><span style="font-size: 12.16px; line-height: 1.3em;">ne donne pas non plus satisfaction car les problèmes obtenus explosent en termes de </span><span style="font-size: 12.16px; line-height: 1.3em;">nombre de variables et clauses et sont de plus totalement illisibles. Des premiers travaux </span><span style="font-size: 12.16px; line-height: 1.3em;">[5, 3, 4] ont été réalisés sur la transformation plus astucieuse de CSP ensemblistes vers </span><span style="font-size: 12.16px; line-height: 1.3em;">SAT. L’approche de transformation choisie est basée sur un encodage automatique des </span><span style="font-size: 12.16px; line-height: 1.3em;">contraintes en SAT. Le codage se fait par règles, chaque règle encodant une contrainte </span><span style="font-size: 12.16px; line-height: 1.3em;">particulière (e.g., intersection, union, appartenance, cardinalité) par des variables boo</span><span style="font-size: 12.16px; line-height: 1.3em;">léennes et clauses correspondantes.</span></p>\r\n<p> </p>\r\n<p>L’objectif de cette thèse est double (pratique et théorique). Du côté pratique, elle <span style="font-size: 12.16px; line-height: 1.3em;">permettra d’enrichir le système de transformation actuel avec de nouvelles règles pour </span><span style="font-size: 12.16px; line-height: 1.3em;">augmenter la bibliothèque de contraintes traitées (e.g. contraintes arithmétiques, certaines </span><span style="font-size: 12.16px; line-height: 1.3em;">contraintes globales). Afin de rendre accessible et utilisable par tous l’approche proposée, </span><span style="font-size: 12.16px; line-height: 1.3em;">il faudra également brancher le moteur de règles et le solveur SAT à des langages de mo</span><span style="font-size: 12.16px; line-height: 1.3em;">délisation CSP normalisés et reconnus comme Minizinc [1] et XCSP3 [2]. Cela permettra </span><span style="font-size: 12.16px; line-height: 1.3em;">de comparer l’approche par transformation aux solveurs CSP actuels comme Gecode [6] </span><span style="font-size: 12.16px; line-height: 1.3em;">mais aussi de rendre la conversion du problème en SAT transparente pour l’utilisateur. </span><span style="font-size: 12.16px; line-height: 1.3em;">Du côté théorique, une étude sur les différents mécanismes de simplification sera me</span><span style="font-size: 12.16px; line-height: 1.3em;">née. Le premier point de cette étude concernera la comparaison des mécanismes de ré</span><span style="font-size: 12.16px; line-height: 1.3em;">duction SAT et CSP. En effet, la modélisation naïve d’un problème en CSP est rarement </span><span style="font-size: 12.16px; line-height: 1.3em;">la plus concise en termes de contraintes et de variables. En CSP, deux approches com</span><span style="font-size: 12.16px; line-height: 1.3em;">plémentaires sont souvent utilisées pour réduire la taille de ces instances : la détection </span><span style="font-size: 12.16px; line-height: 1.3em;">de symétries et l’application de règles de réduction. Casser les symétries d’un problème </span><span style="font-size: 12.16px; line-height: 1.3em;">diminue énormément sa taille mais supprime des solutions ce qui peut rendre l’instance </span><span style="font-size: 12.16px; line-height: 1.3em;">plus difficile à résoudre. Au contraire, réduire l’instance à l’aide de règles de réduction </span><span style="font-size: 12.16px; line-height: 1.3em;">conserve toutes les solutions, mais la réduction est souvent moindre. Dans la communauté </span><span style="font-size: 12.16px; line-height: 1.3em;">SAT, les travaux sur les symétries sont assez peu nombreux. Par contre, la réduction est </span><span style="font-size: 12.16px; line-height: 1.3em;">très utilisée et se fait principalement grâce à la propagation unitaire. D’autres mécanismes </span><span style="font-size: 12.16px; line-height: 1.3em;">tels que la subsomption sont aussi utilisés mais peu de travaux y font référence. Com</span><span style="font-size: 12.16px; line-height: 1.3em;">ment contrôler les réductions CSP et SAT de manière à obtenir une instance plus facile </span><span style="font-size: 12.16px; line-height: 1.3em;">à résoudre tout en restant lisible est une question ouverte.</span></p>\r\n<p>Le deuxième point de l’étude théorique concernera la mise en évidence de propriétés <span style="font-size: 12.16px; line-height: 1.3em;">cachées apparaissant uniquement lors de l’utilisation combinée de certaines contraintes. </span><span style="font-size: 12.16px; line-height: 1.3em;">Les contraintes globales peuvent être vues comme des boîtes noires intégrant un algo</span><span style="font-size: 12.16px; line-height: 1.3em;">rithme efficace de traitement. Même si ce cadre étanche permet facilement d’ajouter des </span><span style="font-size: 12.16px; line-height: 1.3em;">nouvelles contraintes globales à un solveur, il ne permet pas de raisonner sur l’ensemble </span><span style="font-size: 12.16px; line-height: 1.3em;">des contraintes (des boîtes noires). Nous croyons que la transformation de modèles per</span><span style="font-size: 12.16px; line-height: 1.3em;">mettra de découvrir certaines de ces propriétés cachées. En effet, en travaillant avec un </span><span style="font-size: 12.16px; line-height: 1.3em;">langage intermédiaire de modélisation, ici le langage SAT, l’information est disponible.</span></p>\r\n<p><span style="font-size: 12.16px; line-height: 1.3em;">Tout le travail d’analyse qui s’en suivra devrait permettre de mettre en évidence ces </span><span style="font-size: 12.16px; line-height: 1.3em;">propriétés afin d’en faire profiter le solveur SAT.</span></p>\r\n<p> </p>\r\n<p>Références</p>\r\n<p>[1] Minizinc. http ://www.minizinc.org/.</p>\r\n<p>[2] Frédéric Boussemart, Christophe Lecoutre, Cédric Piette, and Vincent Perradin.</p>\r\n<p>XCSP3 an integrated format for benchmarking combinatorial constrained problems.</p>\r\n<p>http ://www.xcsp.org/.</p>\r\n<p>[3] Frédéric Lardeux and Eric Monfroy. From declarative set constraint models to "good"</p>\r\n<p>SAT instances. In Artificial Intelligence and Symbolic Computation - 12th Internatio-</p>\r\n<p>nal Conference, AISC 2014, Seville, Spain, December 11-13, 2014. Proceedings, pages</p>\r\n<p>76–87, 2014.</p>\r\n<p>[4] Frédéric Lardeux and Eric Monfroy. Expressively modeling the social golfer problem</p>\r\n<p>in SAT. In Proceedings of the International Conference on Computational Science,</p>\r\n<p>ICCS 2015, Computational Science at the Gates of Nature, Reykjavík, Iceland, 1-3</p>\r\n<p>June, 2015, 2014, pages 336–345, 2015.</p>\r\n<p>[5] Frédéric Lardeux, Eric Monfroy, Broderick Crawford, and Ricardo Soto. Set constraint</p>\r\n<p>model and automated encoding into SAT : application to the social golfer problem.</p>\r\n<p>Annals OR, 235(1) :423–452, 2015.</p>\r\n<p>[6] Christian Schulte. http ://www.gecode.org. Contributions to Gecode were made by</p>\r\n<p>Vincent Barichard, including float variables and float constraints.</p>\r\n<p> </p>